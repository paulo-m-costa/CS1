# Paulo Costa - Lab 3 Section D

'''
lab3d.py
Simple L-system simulator.
'''

# References: 
#   http://en.wikipedia.org/wiki/L-systems
#   http://www.kevs3d.co.uk/dev/lsystems/
# N.B. http://en.wikipedia.org/wiki/MU_puzzle for midterm?

import math

# ---------------------------------------------------------------------- 
# Example L-systems.
# ---------------------------------------------------------------------- 

# Koch snowflake.
koch = { 'start' : 'F++F++F', 
         'F'     : 'F-F++F-F' }
koch_draw = { 'F' : 'F 1', 
              '+' : 'R 60', 
              '-' : 'L 60' }

# Hilbert curve.
hilbert  = { 'start' : 'A', 
             'A'     : '-BF+AFA+FB-' , 
             'B'     : '+AF-BFB-FA+' }
hilbert_draw = { 'F' : 'F 1', 
                 '-' : 'L 90', 
                 '+' : 'R 90' }

# Sierpinski triangle.
sierpinski = { 'start' : 'F-G-G', 
               'F'     : 'F-G+F+G-F', 
               'G'     : 'GG' }
sierpinski_draw = { 'F' : 'F 1', 
                    'G' : 'F 1', 
                    '+' : 'L 120', 
                    '-' : 'R 120' }

# ---------------------------------------------------------------------- 
# L-systems functions.
# ---------------------------------------------------------------------- 

# Ex D.1:
def update(dictionary, initial_string):
    '''This function takes two input arguments: a dictionary which specifies
    both the starting string and the update rules for a particular L-system, and
    an initial L-system string. It then generates the next iteration of the 
    L-system string by applying the L-system rules to each character of the 
    string and combining all the strings into one big string. Note that any 
    character which is not a key in the L-system dictionary is copied into the
    new string unchanged.'''
    new_string = ''
    for char in initial_string:
        if char in dictionary:
            new_string += dictionary[char]
        else:
            new_string += char
    return new_string

# Ex D.2:
def iterate(dictionary, n):
    '''This function takes two input arguments: an L-system dictionary, and an 
    integer n that is 0 or greater. It returns nth iteration of the L-system
    using the update function.'''
    new_string = dictionary['start']
    for i in range(n):
        new_string = update(dictionary, new_string)
    return new_string

# Ex D.3:
def lsystemToDrawingCommands(draw_dict, string):
    '''This function takes two input arguments: a dictionary whose keys are 
    characters in L-system strings and whose values are drawing commands, and
    an L-system string. It returns the list of commands needed to draw the 
    figure corresponding to the L-system string.'''
    new_list = []
    for c in list(string):
        if c in draw_dict:
            new_list.append(draw_dict[c])
    return new_list

# Ex D.5:
def bounds(command_list):
    '''This function takes a list of commands generated by the function 
    lsystemToDrawingCommands as input and computes the bounding coordinates of
    the resulting drawing i.e. the minimum and maximum x and y coordinates 
    ever achieved by the turtle as it moves to make the drawing. It returns a 
    quadruple: the (xmin, xmax, ymin, ymax) coordinates as floats.'''
    x_new = 0.0
    y_new = 0.0
    angle_new = 0.0 # We assume the turtle starts along the horizontal.
    x_max = 0.0
    x_min = 0.0
    y_max = 0.0
    y_min = 0.0
    for com in command_list:
        (x_new, y_new, angle_new) = nextLocation(x_new, y_new, angle_new, com)
        if x_new > x_max:
            x_max = x_new
        elif x_new < x_min:
            x_min = x_new
        if y_new > y_max:
            y_max = y_new
        elif y_new < y_min:
            y_min = y_new
    return (x_min, x_max, y_min, y_max)

# Ex D.4:
def nextLocation(x, y, angle, command):
    '''This function takes four input arguments: the current x coordinate value
    of the turtle, the current y coordinate value, the current direction (angle 
    from the horizontal) the turtle is facing, and a drawing command. It then
    generates the next location and direction of the turtle after that drawing
    command has executed. It returns a triple: the next x coordinate of the 
    turtle, the next y coordinate, and the next angle.'''
    x_new = float(x)
    y_new = float(y)
    angle_rad = angle * (math.pi / 180)
    command_list = command.split()
    if command_list[0] == 'F':
        x_new += float(command_list[1]) * math.cos(angle_rad)
        y_new += float(command_list[1]) * math.sin(angle_rad)
    elif command_list[0] == 'L':
        angle += float(command_list[1])
    else:
        angle -= float(command_list[1])
    angle = angle % 360
    return (x_new, y_new, angle)

# Ex D.6:
def saveDrawing(file_name, bounds_tuple, command_list):
    '''This function takes three input arguments: a filename to write to, the
    output of the bounds function, and a list of drawing commands generated by 
    the lsystemToDrawingCommands function.'''
    file = open(file_name, 'w')
    for el in bounds_tuple:
        file.write(str(el) + ' ')
    for com in command_list:
        file.write('\n' + com)
    file.close()

def makeDrawings(name, lsys, ldraw, imin, imax):
    '''Makes a series of L-system drawings.'''
    print 'Making drawings for %s...' % name
    for i in range(imin, imax):
        l = iterate(lsys, i)
        cmds = lsystemToDrawingCommands(ldraw, l)
        b = bounds(cmds)
        saveDrawing('%s_%d' % (name, i), b, cmds)

def main():
    '''Main function which calls makeDrawings to generate different drawings.'''
    makeDrawings('koch', koch, koch_draw, 0, 6)
    makeDrawings('hilbert', hilbert, hilbert_draw, 1, 6)
    makeDrawings('sierpinski', sierpinski, sierpinski_draw, 0, 10)